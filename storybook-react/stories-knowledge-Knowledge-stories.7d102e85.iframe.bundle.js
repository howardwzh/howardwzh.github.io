/*! For license information please see stories-knowledge-Knowledge-stories.7d102e85.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkstorybook_react=self.webpackChunkstorybook_react||[]).push([[490],{"./src/stories/knowledge/Knowledge.stories.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Composition:()=>Composition,EventHandling:()=>EventHandling,Form:()=>Form,HOC:()=>HOC,Hooks:()=>Hooks,JSX:()=>JSX,MountAndUnmount:()=>MountAndUnmount,Performance:()=>Performance,SSR:()=>SSR,State:()=>State,VirtualDOM:()=>VirtualDOM,__namedExportsOrder:()=>__namedExportsOrder,default:()=>Knowledge_stories});var react=__webpack_require__("./node_modules/react/index.js"),jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js");const Counter=_ref=>{let{initialCount=0}=_ref;const[count,setCount]=(0,react.useState)(initialCount);return(0,react.useEffect)((()=>(console.log("Component mounted"),()=>{console.log("Component will unmount")})),[]),(0,react.useEffect)((()=>{console.log("Count updated:",count)}),[count]),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsxs)("p",{children:["You clicked ",count," times"]}),(0,jsx_runtime.jsx)("button",{onClick:()=>setCount(count+1),children:"Click me"})]})};Counter.__docgenInfo={description:"",methods:[],displayName:"Counter",props:{initialCount:{required:!1,tsType:{name:"number"},description:"",defaultValue:{value:"0",computed:!1}}}};const Story=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h5",{children:"JSX (JavaScript XML)"}),(0,jsx_runtime.jsx)("p",{children:"JSX 是 JavaScript 的语法扩展，允许在 JavaScript 代码中写类似 HTML 的代码。"}),(0,jsx_runtime.jsx)("p",{children:"JSX 通过 Babel 转译成 React.createElement()，从而在浏览器中运行。"}),(0,jsx_runtime.jsx)("pre",{className:"bg-gray-100 p-4 rounded-md",children:(0,jsx_runtime.jsx)("code",{children:"const element = <h1>Hello, world!</h1>;\nReactDOM.render(element, document.getElementById('root'));"})}),(0,jsx_runtime.jsx)(Counter,{})]}),StoryJSX=Story;Story.__docgenInfo={description:"",methods:[],displayName:"Story"};const StoryMountAndUnmount=()=>{const[show,setShow]=react.useState(!0);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("p",{children:"点击按钮，可以加载和卸载组件"}),(0,jsx_runtime.jsx)("button",{onClick:()=>setShow(!show),children:"Toggle"}),(0,jsx_runtime.jsxs)("p",{children:["当前状态：",(0,jsx_runtime.jsx)("span",{children:show?"已加载":"已卸载"})]}),(0,jsx_runtime.jsx)("div",{className:"h-[100px]",children:show&&(0,jsx_runtime.jsx)(Counter,{})})]})},knowledge_StoryMountAndUnmount=StoryMountAndUnmount;function withLoading(WrappedComponent){let loadingTime=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1500;return function WithLoading(props){const[isLoading,setIsLoading]=(0,react.useState)(!0);return(0,react.useEffect)((()=>{const timer=setTimeout((()=>{setIsLoading(!1)}),loadingTime);return()=>clearTimeout(timer)}),[]),isLoading?(0,jsx_runtime.jsx)("div",{children:"Loading..."}):(0,jsx_runtime.jsx)(WrappedComponent,{...props})}}StoryMountAndUnmount.__docgenInfo={description:"",methods:[],displayName:"StoryMountAndUnmount"};const UserProfile=_ref=>{let{name,email}=_ref;return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h2",{children:"User Profile"}),(0,jsx_runtime.jsxs)("p",{children:["Name: ",name]}),(0,jsx_runtime.jsxs)("p",{children:["Email: ",email]})]})};withLoading(UserProfile);UserProfile.__docgenInfo={description:"",methods:[],displayName:"UserProfile",props:{name:{required:!0,tsType:{name:"string"},description:""},email:{required:!0,tsType:{name:"string"},description:""}}};const knowledge_StoryHOC=()=>{const CustomLoadingComponent=withLoading(UserProfile,3e3);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h5",{children:"高阶组件 (HOC)"}),(0,jsx_runtime.jsx)("p",{children:"高阶组件（HOC）是 React 中的一种设计模式，允许你通过组合现有组件来创建新组件。"}),(0,jsx_runtime.jsx)("p",{children:"HOC 是一种函数，它接受一个组件作为参数，并返回一个新的组件。"}),(0,jsx_runtime.jsx)("p",{children:"HOC 可以用于添加额外的 props、state、或行为到组件中。"}),(0,jsx_runtime.jsx)("div",{className:"bg-gray-100 p-4 rounded-md",children:(0,jsx_runtime.jsx)(CustomLoadingComponent,{name:"Bob Johnson",email:"bob@example.com"})})]})},ThemeContext=(0,react.createContext)("light"),counterReducer=(state,action)=>{switch(action.type){case"increment":return{count:state.count+1};case"decrement":return{count:state.count-1};default:return state}},AllHooksDemo=()=>{const[name,setName]=(0,react.useState)("");(0,react.useEffect)((()=>{document.title=`Name: ${name}`}),[name]);const theme=(0,react.useContext)(ThemeContext),[state,dispatch]=(0,react.useReducer)(counterReducer,{count:0}),expensiveComputation=(0,react.useMemo)((()=>1e3*state.count),[state.count]),handleClick=(0,react.useCallback)((()=>{console.log(`Button clicked. Count: ${state.count}`)}),[state.count]),windowWidth=(()=>{const[width,setWidth]=(0,react.useState)(window.innerWidth);return(0,react.useEffect)((()=>{const handleResize=()=>setWidth(window.innerWidth);return window.addEventListener("resize",handleResize),()=>window.removeEventListener("resize",handleResize)}),[]),width})();return(0,jsx_runtime.jsxs)("div",{style:{padding:"20px",backgroundColor:"light"===theme?"#f0f0f0":"#333",color:"light"===theme?"#000":"#fff"},children:[(0,jsx_runtime.jsx)("h2",{children:"All Hooks Demo"}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"useState & useEffect"}),(0,jsx_runtime.jsx)("input",{value:name,onChange:e=>setName(e.target.value),placeholder:"Enter your name"}),(0,jsx_runtime.jsxs)("p",{children:["Name: ",name]})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"useContext"}),(0,jsx_runtime.jsxs)("p",{children:["Current theme: ",theme]})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"useReducer"}),(0,jsx_runtime.jsxs)("p",{children:["Count: ",state.count]}),(0,jsx_runtime.jsx)("button",{onClick:()=>dispatch({type:"increment"}),children:"+"}),(0,jsx_runtime.jsx)("button",{onClick:()=>dispatch({type:"decrement"}),children:"-"})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"useMemo"}),(0,jsx_runtime.jsxs)("p",{children:["Expensive Computation Result: ",expensiveComputation]})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"useCallback"}),(0,jsx_runtime.jsx)("button",{onClick:handleClick,children:"Log Count"})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"Custom Hook (useWindowWidth)"}),(0,jsx_runtime.jsxs)("p",{children:["Window width: ",windowWidth,"px"]})]})]})};AllHooksDemo.__docgenInfo={description:"",methods:[],displayName:"AllHooksDemo"};const StoryHooks=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h5",{children:"Hooks"}),(0,jsx_runtime.jsx)("p",{children:"Hooks 是 React 16.8 引入的新特性，允许你在函数组件中使用状态和其他 React 特性。"}),(0,jsx_runtime.jsx)("p",{children:"Hooks 可以用于解决特定问题："}),(0,jsx_runtime.jsxs)("ul",{children:[(0,jsx_runtime.jsx)("li",{children:"useState 用于本地组件状态"}),(0,jsx_runtime.jsx)("li",{children:"useEffect 用于副作用"}),(0,jsx_runtime.jsx)("li",{children:"useContext 用于访问共享数据"}),(0,jsx_runtime.jsx)("li",{children:"useReducer 用于复杂状态逻辑"}),(0,jsx_runtime.jsx)("li",{children:"useMemo 用于性能优化"}),(0,jsx_runtime.jsx)("li",{children:"useCallback 用于性能优化"}),(0,jsx_runtime.jsx)("li",{children:"Custom Hooks 用于提取组件逻辑"})]}),(0,jsx_runtime.jsx)(AllHooksDemo,{})]}),knowledge_StoryHooks=StoryHooks;StoryHooks.__docgenInfo={description:"",methods:[],displayName:"StoryHooks"};const StoryState_ThemeContext=(0,react.createContext)("light"),InternalStateComponent=()=>{const[count,setCount]=(0,react.useState)(0);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"组件内部状态"}),(0,jsx_runtime.jsxs)("p",{children:["计数: ",count]}),(0,jsx_runtime.jsx)("button",{onClick:()=>setCount(count+1),children:"增加"})]})},ChildComponent=_ref=>{let{message}=_ref;return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"Props"}),(0,jsx_runtime.jsxs)("p",{children:["来自父组件的消息: ",message]})]})},ThemedComponent=()=>{const theme=(0,react.useContext)(StoryState_ThemeContext);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"Context API"}),(0,jsx_runtime.jsxs)("p",{children:["当前主题: ",theme]})]})},StoryState=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h2",{children:"状态管理 (State Management)"}),(0,jsx_runtime.jsx)(InternalStateComponent,{}),(0,jsx_runtime.jsx)(ChildComponent,{message:"这是通过 props 传递的消息"}),(0,jsx_runtime.jsx)(StoryState_ThemeContext.Provider,{value:"dark",children:(0,jsx_runtime.jsx)(ThemedComponent,{})}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"外部状态管理工具"}),(0,jsx_runtime.jsx)("p",{children:"Redux、MobX、Recoil 等用于处理更复杂的应用状态。"}),(0,jsx_runtime.jsx)("p",{children:"这些工具通常用于大型应用，需要单独设置和配置。"})]})]}),knowledge_StoryState=StoryState;StoryState.__docgenInfo={description:"",methods:[],displayName:"StoryState"};const StoryVirtualDOM=()=>{const[count,setCount]=(0,react.useState)(0),[list,setList]=(0,react.useState)(["Item 1","Item 2","Item 3"]),listRef=(0,react.useRef)(null);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h2",{children:"虚拟 DOM 演示"}),(0,jsx_runtime.jsx)("p",{children:"虚拟 DOM 允许 React 在内存中计算变更，然后高效地更新实际 DOM。 下面的例子展示了 React 如何只更新必要的部分。"}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsxs)("p",{children:["计数器: ",count]}),(0,jsx_runtime.jsx)("button",{onClick:()=>setCount(count+1),children:"增加计数"})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("ul",{ref:listRef,children:list.map(((item,index)=>(0,jsx_runtime.jsx)("li",{className:"updated",children:item},index)))}),(0,jsx_runtime.jsx)("button",{onClick:()=>{setList([...list,`Item ${list.length+1}`])},children:"添加项目"})]}),(0,jsx_runtime.jsx)("p",{children:'注意：当你点击"增加计数"时，只有计数器会更新。 当你点击"添加项目"时，只有新的项目会被添加，现有项目不会重新渲染。 这展示了 React 的高效更新机制。'}),(0,jsx_runtime.jsx)("style",{children:"\n        .updated {\n          animation: fadeIn 1s ease-in-out;\n        }\n        @keyframes fadeIn {\n          from {\n            opacity: 0;\n          }\n          to {\n            opacity: 1;\n            background-color: yellow;\n          }\n        }\n      "})]})},knowledge_StoryVirtualDOM=StoryVirtualDOM;StoryVirtualDOM.__docgenInfo={description:"",methods:[],displayName:"StoryVirtualDOM"};const ListWithKeys=()=>{const[items,setItems]=(0,react.useState)(["Item 1","Item 2","Item 3"]);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"Key 优化"}),(0,jsx_runtime.jsx)("p",{children:"使用 key 优化列表渲染。 在 React 中，使用 key 可以帮助 React 识别哪些元素发生了变化，从而优化渲染过程。 在实际应用中，最好使用唯一 ID 作为 key。 使用 key 可以提高渲染性能，减少不必要的重新渲染。"}),(0,jsx_runtime.jsx)("ul",{children:items.map(((item,index)=>(0,jsx_runtime.jsx)("li",{children:item},index)))}),(0,jsx_runtime.jsx)("button",{onClick:()=>{setItems([...items,`Item ${items.length+1}`])},children:"添加项目"})]})},ExpensiveComponent=react.memo((_ref=>{let{value}=_ref;return console.log("ExpensiveComponent rendered"),(0,jsx_runtime.jsxs)("div",{children:["Expensive Calculation Result: ",2*value]})})),MemoizationDemo=()=>{const[count,setCount]=(0,react.useState)(0),[value,setValue]=(0,react.useState)(10),expensiveValue=(0,react.useMemo)((()=>(console.log("Expensive calculation performed"),2*value)),[value]);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"Memoization (React.memo 和 useMemo)"}),(0,jsx_runtime.jsx)("p",{children:"React.memo 和 useMemo 是 React 中用于优化性能的工具。 React.memo 用于优化组件渲染，useMemo 用于优化计算结果的缓存。 使用 memoization 可以减少不必要的渲染，提高应用的性能。"}),(0,jsx_runtime.jsxs)("p",{children:["Count: ",count]}),(0,jsx_runtime.jsx)("button",{onClick:()=>setCount(count+1),children:"Increment Count"}),(0,jsx_runtime.jsx)(ExpensiveComponent,{value:expensiveValue}),(0,jsx_runtime.jsx)("button",{onClick:()=>setValue(value+1),children:"Change Value"})]})},LazyComponent=(0,react.lazy)((()=>__webpack_require__.e(702).then(__webpack_require__.bind(__webpack_require__,"./src/stories/knowledge/LazyComponent.tsx")))),CodeSplittingDemo=()=>{const[showLazy,setShowLazy]=(0,react.useState)(!1);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"代码拆分 (React.lazy 和 Suspense)"}),(0,jsx_runtime.jsx)("p",{children:"React.lazy 和 Suspense 是 React 中用于代码拆分的工具。 React.lazy 用于懒加载组件，Suspense 用于在组件加载时显示 fallback 内容。 代码拆分可以提高应用的加载速度和性能。"}),(0,jsx_runtime.jsxs)("button",{onClick:()=>setShowLazy(!showLazy),children:[showLazy?"Hide":"Show"," Lazy Component"]}),showLazy&&(0,jsx_runtime.jsx)(react.Suspense,{fallback:(0,jsx_runtime.jsx)("div",{children:"Loading..."}),children:(0,jsx_runtime.jsx)(LazyComponent,{})})]})},StoryPerformance_ChildComponent=react.memo((_ref2=>{let{onClick}=_ref2;return console.log("ChildComponent rendered"),(0,jsx_runtime.jsx)("button",{onClick,children:"Click me"})})),UseCallbackDemo=()=>{const[count,setCount]=(0,react.useState)(0),handleClick=(0,react.useCallback)((()=>{console.log("Button clicked")}),[]);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"useCallback"}),(0,jsx_runtime.jsx)("p",{children:"useCallback 是 React 中用于优化性能的工具。 useCallback 用于缓存回调函数，避免不必要的重新渲染。 使用 useCallback 可以提高应用的性能。"}),(0,jsx_runtime.jsxs)("p",{children:["Count: ",count]}),(0,jsx_runtime.jsx)("button",{onClick:()=>setCount(count+1),children:"Increment Count"}),(0,jsx_runtime.jsx)(StoryPerformance_ChildComponent,{onClick:handleClick})]})},StoryPerformance=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h2",{children:"性能优化技巧"}),(0,jsx_runtime.jsx)(ListWithKeys,{}),(0,jsx_runtime.jsx)(MemoizationDemo,{}),(0,jsx_runtime.jsx)(CodeSplittingDemo,{}),(0,jsx_runtime.jsx)(UseCallbackDemo,{}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"shouldComponentUpdate"}),(0,jsx_runtime.jsx)("p",{children:"这是类组件中的一个生命周期方法，用于判断组件是否需要重新渲染。 在函数组件中，可以使用 React.memo 实现类似的效果。 使用 shouldComponentUpdate 可以提高渲染性能，减少不必要的重新渲染。"})]})]}),knowledge_StoryPerformance=StoryPerformance;StoryPerformance.__docgenInfo={description:"",methods:[],displayName:"StoryPerformance"};const FunctionalEventHandling=()=>{const[message,setMessage]=(0,react.useState)("");return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"函数组件中的事件处理"}),(0,jsx_runtime.jsx)("button",{onClick:event=>{setMessage("按钮被点击了！"),console.log("事件对象:",event)},children:"点击我"}),(0,jsx_runtime.jsx)("input",{type:"text",onChange:event=>{setMessage(`输入的值: ${event.target.value}`)},placeholder:"输入些什么..."}),(0,jsx_runtime.jsx)("p",{children:message})]})};class ClassEventHandling extends react.Component{constructor(){super(...arguments),this.state={message:""},this.handleClick=event=>{this.setState({message:"按钮被点击了！"}),console.log("事件对象:",event)},this.handleChange=event=>{this.setState({message:`输入的值: ${event.target.value}`})}}render(){return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"类组件中的事件处理"}),(0,jsx_runtime.jsx)("button",{onClick:this.handleClick,children:"点击我"}),(0,jsx_runtime.jsx)("input",{type:"text",onChange:this.handleChange,placeholder:"输入些什么..."}),(0,jsx_runtime.jsx)("p",{children:this.state.message})]})}}const SyntheticEventDemo=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"合成事件示例"}),(0,jsx_runtime.jsx)("div",{onMouseEnter:event=>{console.log("鼠标进入:",event.clientX,event.clientY)},onMouseLeave:event=>{console.log("鼠标离开:",event.clientX,event.clientY)},style:{width:"200px",height:"100px",backgroundColor:"lightblue"},children:"鼠标移入移出这个区域"}),(0,jsx_runtime.jsx)("p",{children:"查看控制台以了解事件细节"})]}),StoryEventHandling=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h2",{children:"React 事件处理"}),(0,jsx_runtime.jsx)("p",{children:"React 使用合成事件系统（Synthetic Events），确保跨浏览器兼容性。 事件绑定的方式与标准 HTML 不同，需要使用驼峰命名法，并传递一个函数作为事件处理器。"}),(0,jsx_runtime.jsx)(FunctionalEventHandling,{}),(0,jsx_runtime.jsx)(ClassEventHandling,{}),(0,jsx_runtime.jsx)(SyntheticEventDemo,{})]}),knowledge_StoryEventHandling=StoryEventHandling;StoryEventHandling.__docgenInfo={description:"",methods:[],displayName:"StoryEventHandling"};const ControlledComponent=()=>{const[inputValue,setInputValue]=(0,react.useState)(""),[textareaValue,setTextareaValue]=(0,react.useState)(""),[selectValue,setSelectValue]=(0,react.useState)("");return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"受控组件"}),(0,jsx_runtime.jsxs)("form",{onSubmit:event=>{event.preventDefault(),alert(`提交的数据：\n输入框：${inputValue}\n文本域：${textareaValue}\n选择框：${selectValue}`)},children:[(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("label",{htmlFor:"controlled-input",children:"输入框："}),(0,jsx_runtime.jsx)("input",{id:"controlled-input",type:"text",value:inputValue,onChange:e=>setInputValue(e.target.value)})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("label",{htmlFor:"controlled-textarea",children:"文本域："}),(0,jsx_runtime.jsx)("textarea",{id:"controlled-textarea",value:textareaValue,onChange:e=>setTextareaValue(e.target.value)})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("label",{htmlFor:"controlled-select",children:"选择框："}),(0,jsx_runtime.jsxs)("select",{id:"controlled-select",value:selectValue,onChange:e=>setSelectValue(e.target.value),children:[(0,jsx_runtime.jsx)("option",{value:"",children:"请选择"}),(0,jsx_runtime.jsx)("option",{value:"option1",children:"选项1"}),(0,jsx_runtime.jsx)("option",{value:"option2",children:"选项2"}),(0,jsx_runtime.jsx)("option",{value:"option3",children:"选项3"})]})]}),(0,jsx_runtime.jsx)("button",{type:"submit",children:"提交"})]})]})},UncontrolledComponent=()=>{const inputRef=(0,react.useRef)(null),textareaRef=(0,react.useRef)(null),selectRef=(0,react.useRef)(null);return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"非受控组件"}),(0,jsx_runtime.jsxs)("form",{onSubmit:event=>{var _inputRef$current,_textareaRef$current,_selectRef$current;event.preventDefault();const inputValue=null===(_inputRef$current=inputRef.current)||void 0===_inputRef$current?void 0:_inputRef$current.value,textareaValue=null===(_textareaRef$current=textareaRef.current)||void 0===_textareaRef$current?void 0:_textareaRef$current.value,selectValue=null===(_selectRef$current=selectRef.current)||void 0===_selectRef$current?void 0:_selectRef$current.value;alert(`提交的数据：\n输入框：${inputValue}\n文本域：${textareaValue}\n选择框：${selectValue}`)},children:[(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("label",{htmlFor:"uncontrolled-input",children:"输入框："}),(0,jsx_runtime.jsx)("input",{id:"uncontrolled-input",type:"text",ref:inputRef,defaultValue:""})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("label",{htmlFor:"uncontrolled-textarea",children:"文本域："}),(0,jsx_runtime.jsx)("textarea",{id:"uncontrolled-textarea",ref:textareaRef,defaultValue:""})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("label",{htmlFor:"uncontrolled-select",children:"选择框："}),(0,jsx_runtime.jsxs)("select",{id:"uncontrolled-select",ref:selectRef,defaultValue:"",children:[(0,jsx_runtime.jsx)("option",{value:"",children:"请选择"}),(0,jsx_runtime.jsx)("option",{value:"option1",children:"选项1"}),(0,jsx_runtime.jsx)("option",{value:"option2",children:"选项2"}),(0,jsx_runtime.jsx)("option",{value:"option3",children:"选项3"})]})]}),(0,jsx_runtime.jsx)("button",{type:"submit",children:"提交"})]})]})},StoryForm=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h2",{children:"React 表单处理"}),(0,jsx_runtime.jsx)("p",{children:"React 提供了两种处理表单输入的方式：受控组件和非受控组件。 受控组件通过 React 状态控制表单元素的值，而非受控组件则直接通过 DOM 操作。"}),(0,jsx_runtime.jsx)(ControlledComponent,{}),(0,jsx_runtime.jsx)(UncontrolledComponent,{})]}),knowledge_StoryForm=StoryForm;StoryForm.__docgenInfo={description:"",methods:[],displayName:"StoryForm"};const Card=_ref=>{let{children}=_ref;return(0,jsx_runtime.jsx)("div",{style:{border:"1px solid #ccc",borderRadius:"4px",padding:"16px",margin:"8px"},children})},SpecialCard=_ref2=>{let{title,children}=_ref2;return(0,jsx_runtime.jsxs)(Card,{children:[(0,jsx_runtime.jsx)("h3",{children:title}),children]})},UserCardContainer=_ref3=>{let{userId}=_ref3;const user={id:userId,name:"张三",email:"zhangsan@example.com"};return(0,jsx_runtime.jsx)(UserCardPresentation,{user})},UserCardPresentation=_ref4=>{let{user}=_ref4;return(0,jsx_runtime.jsxs)(Card,{children:[(0,jsx_runtime.jsx)("h3",{children:user.name}),(0,jsx_runtime.jsxs)("p",{children:["ID: ",user.id]}),(0,jsx_runtime.jsxs)("p",{children:["Email: ",user.email]})]})},CompositionExample=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"组合示例"}),(0,jsx_runtime.jsx)(Card,{children:(0,jsx_runtime.jsx)("p",{children:"这是一个基础卡片"})}),(0,jsx_runtime.jsx)(SpecialCard,{title:"特殊卡片",children:(0,jsx_runtime.jsx)("p",{children:"这是一个使用组合创建的特殊卡片"})}),(0,jsx_runtime.jsx)(UserCardContainer,{userId:1})]});class BaseComponent extends react.Component{render(){return(0,jsx_runtime.jsx)("div",{children:this.props.message})}}class InheritedComponent extends BaseComponent{render(){return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h4",{children:"继承的组件："}),super.render()]})}}const InheritanceExample=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"继承示例（不推荐）"}),(0,jsx_runtime.jsx)(InheritedComponent,{message:"这是通过继承创建的组件"})]}),StoryComposition=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h2",{children:"组合 vs 继承"}),(0,jsx_runtime.jsx)("p",{children:"React 推荐使用组合而不是继承来实现代码复用。 组合允许更灵活的设计，并且可以通过 props 和 children 来定制组件行为。"}),(0,jsx_runtime.jsx)(CompositionExample,{}),(0,jsx_runtime.jsx)(InheritanceExample,{}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"组合的优势"}),(0,jsx_runtime.jsxs)("ul",{children:[(0,jsx_runtime.jsx)("li",{children:"更灵活：可以通过 props 和 children 轻松定制组件"}),(0,jsx_runtime.jsx)("li",{children:"更易于理解：组件之间的关系更加明确"}),(0,jsx_runtime.jsx)("li",{children:"更好的封装：组件的内部实现对外部是隐藏的"}),(0,jsx_runtime.jsx)("li",{children:"更易于测试：可以独立测试每个组件"})]})]})]}),knowledge_StoryComposition=StoryComposition;StoryComposition.__docgenInfo={description:"",methods:[],displayName:"StoryComposition"};const ServerRenderedComponent=_ref=>{let{initialData}=_ref;return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"服务器端渲染的组件"}),(0,jsx_runtime.jsxs)("p",{children:["初始数据（来自服务器）: ",initialData]})]})},ClientRenderedComponent=()=>{const[data,setData]=react.useState("加载中...");return react.useEffect((()=>{setTimeout((()=>{setData("这是客户端获取的数据")}),1e3)}),[]),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"客户端渲染的组件"}),(0,jsx_runtime.jsxs)("p",{children:["数据: ",data]})]})},IsomorphicComponent=_ref2=>{let{initialData}=_ref2;const[data,setData]=react.useState(initialData);return react.useEffect((()=>{console.log("客户端水合完成")}),[]),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"同构应用组件"}),(0,jsx_runtime.jsxs)("p",{children:["数据: ",data]}),(0,jsx_runtime.jsx)("button",{onClick:()=>setData("更新后的数据"),children:"更新数据"})]})},StorySSR=()=>(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h2",{children:"服务器端渲染 (SSR) 和同构应用"}),(0,jsx_runtime.jsx)("p",{children:"服务器端渲染 (SSR) 是一种在服务器上生成 HTML 的技术，可以提高首次加载性能和搜索引擎优化 (SEO)。 同构应用则是既可以在服务器端渲染，又可以在客户端渲染的应用。"}),(0,jsx_runtime.jsx)(ServerRenderedComponent,{initialData:"这是服务器生成的初始数据"}),(0,jsx_runtime.jsx)(ClientRenderedComponent,{}),(0,jsx_runtime.jsx)(IsomorphicComponent,{initialData:"这是服务器生成的初始数据，但可以在客户端更新"}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"SSR 和同构应用的优势"}),(0,jsx_runtime.jsxs)("ul",{children:[(0,jsx_runtime.jsx)("li",{children:"更好的首次加载性能：用户可以更快地看到内容"}),(0,jsx_runtime.jsx)("li",{children:"改善 SEO：搜索引擎可以更容易地爬取和索引内容"}),(0,jsx_runtime.jsx)("li",{children:"更好的用户体验：特别是在低性能设备或慢网络环境下"}),(0,jsx_runtime.jsx)("li",{children:"同构应用结合了 SSR 和客户端渲染的优点"})]})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"实现 SSR 的常用框架"}),(0,jsx_runtime.jsx)("ul",{children:(0,jsx_runtime.jsx)("li",{children:"Next.js：React 的 SSR 框架"})})]}),(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)("h3",{children:"注意事项"}),(0,jsx_runtime.jsx)("p",{children:"实际的 SSR 实现需要服务器环境。这个演示只是概念性的展示， 无法完全模拟真实的 SSR 过程。在实际应用中，SSR 涉及到服务器端代码执行、 数据预取、状态序列化等复杂过程。"})]})]}),knowledge_StorySSR=StorySSR;StorySSR.__docgenInfo={description:"",methods:[],displayName:"StorySSR"};const Knowledge_stories={title:"知识点new",parameters:{layout:"padded"}},JSX={args:{},render:()=>(0,jsx_runtime.jsx)(StoryJSX,{}),name:"JSX知识"},MountAndUnmount={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StoryMountAndUnmount,{}),name:"生命周期"},HOC={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StoryHOC,{}),name:"高阶组件"},Hooks={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StoryHooks,{}),name:"React Hooks"},State={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StoryState,{}),name:"状态管理"},VirtualDOM={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StoryVirtualDOM,{}),name:"虚拟DOM"},Performance={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StoryPerformance,{}),name:"性能优化"},EventHandling={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StoryEventHandling,{}),name:"事件处理"},Form={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StoryForm,{}),name:"表单处理"},Composition={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StoryComposition,{}),name:"组合 vs 继承"},SSR={args:{},render:()=>(0,jsx_runtime.jsx)(knowledge_StorySSR,{}),name:"SSR和同构应用"},__namedExportsOrder=["JSX","MountAndUnmount","HOC","Hooks","State","VirtualDOM","Performance","EventHandling","Form","Composition","SSR"];JSX.parameters={...JSX.parameters,docs:{...JSX.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryJSX />,\n  name: 'JSX知识'\n}",...JSX.parameters?.docs?.source}}},MountAndUnmount.parameters={...MountAndUnmount.parameters,docs:{...MountAndUnmount.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryMountAndUnmount />,\n  name: '生命周期'\n}",...MountAndUnmount.parameters?.docs?.source}}},HOC.parameters={...HOC.parameters,docs:{...HOC.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryHOC />,\n  name: '高阶组件'\n}",...HOC.parameters?.docs?.source}}},Hooks.parameters={...Hooks.parameters,docs:{...Hooks.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryHooks />,\n  name: 'React Hooks'\n}",...Hooks.parameters?.docs?.source}}},State.parameters={...State.parameters,docs:{...State.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryState />,\n  name: '状态管理'\n}",...State.parameters?.docs?.source}}},VirtualDOM.parameters={...VirtualDOM.parameters,docs:{...VirtualDOM.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryVirtualDOM />,\n  name: '虚拟DOM'\n}",...VirtualDOM.parameters?.docs?.source}}},Performance.parameters={...Performance.parameters,docs:{...Performance.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryPerformance />,\n  name: '性能优化'\n}",...Performance.parameters?.docs?.source}}},EventHandling.parameters={...EventHandling.parameters,docs:{...EventHandling.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryEventHandling />,\n  name: '事件处理'\n}",...EventHandling.parameters?.docs?.source}}},Form.parameters={...Form.parameters,docs:{...Form.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryForm />,\n  name: '表单处理'\n}",...Form.parameters?.docs?.source}}},Composition.parameters={...Composition.parameters,docs:{...Composition.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StoryComposition />,\n  name: '组合 vs 继承'\n}",...Composition.parameters?.docs?.source}}},SSR.parameters={...SSR.parameters,docs:{...SSR.parameters?.docs,source:{originalSource:"{\n  args: {},\n  render: () => <StorySSR />,\n  name: 'SSR和同构应用'\n}",...SSR.parameters?.docs?.source}}}},"./node_modules/react/cjs/react-jsx-runtime.production.min.js":(__unused_webpack_module,exports,__webpack_require__)=>{var f=__webpack_require__("./node_modules/react/index.js"),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};function q(c,a,g){var b,d={},e=null,h=null;for(b in void 0!==g&&(e=""+g),void 0!==a.key&&(e=""+a.key),void 0!==a.ref&&(h=a.ref),a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l,exports.jsx=q,exports.jsxs=q},"./node_modules/react/jsx-runtime.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/react/cjs/react-jsx-runtime.production.min.js")}}]);